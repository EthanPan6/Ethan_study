# 判断JS数据类型的四种方法

在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示：

> **基本类型**：String、Number、Boolean、Symbol、Undefined、Null 
>
> **引用类型**：Object

引用类型除 Object 外，还包括 Function 、Array、RegExp、Date、Set、Map 等等。 

## `typeof`

`typeof` 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：`number、boolean、symbol、string、object、undefined、function `等。 

```js
typeof ''; // string 有效
typeof 1; // number 有效
typeof Symbol(); // symbol 有效
typeof true; //boolean 有效
typeof undefined; //undefined 有效
typeof new Function(); // function 有效

typeof null; //object 无效
typeof [] ; //object 无效
typeof new Date(); //object 无效
typeof new RegExp(); //object 无效
```

+ 基本类型除`null`,都能正确判断
+ 引用类型除了function,都返回object
+ null返回object,function返回function



## `instanceof`

`instanceof `是用来判断 A 是否为 B 的实例,**即只能用来判断引用类型**，表达式为：`A instanceof B`，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：**instanceof 检测的是原型**，我们用一段伪代码来模拟其内部执行过程： 

```js
instanceof (A,B) = {
    var L = A.__proto__;
    var R = B.prototype;
    if(L === R) {
        // A的内部属性 __proto__ 指向 B 的原型对象
        return true;
    }
    return false;
}
```

从上述过程可以看出，当 A 的 __proto__ 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子： 

```js
[] instanceof Array; // true
{} instanceof Object;// true
new Function() instanceof Function//true
new Date() instanceof Date;// true
 
function Person(){};
new Person() instanceof Person;
 
[] instanceof Object; // true
new Date() instanceof Object;// true
new Person instanceof Object;// true
```

我们发现，虽然 `instanceof `能够判断出` [ ]` 是`Array`的实例，但它认为 `[ ]` 也是`Object`的实例，为什么呢？

我们来分析一下` [ ]、Array、Object` 三者之间的关系：

从 `instanceof `能够判断出` [ ].__proto__ ` 指向 `Array.prototype`，而 `Array.prototype.__proto`__ 又指向了`Object.prototype`，最终` Object.prototype.__proto`__ 指向了`null`，标志着原型链的结束。因此，`[]、Array、Object` 就在内部形成了一条原型链：

![指向](E:\study\Ethan_study\Others\数据类型\doc\判断方法.png)

从原型链可以看出，`[]` 的` __proto__  `直接指向`Array.prototype`，间接指向 `Object.prototype`，所以按照 `instanceof `的判断规则，`[] `就是`Object`的实例。依次类推，类似的`new Date()、new Person() `也会形成一条对应的原型链 。因此，**instanceof 只能用来判断两个对象是否属于实例关系****， 而不能判断一个对象实例具体属于哪种类型。

