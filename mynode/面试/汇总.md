# 前端面试题汇总
## html
## css
## js
### 字符串
+ 找出字符串中连续出现最多的字符和个数
  
    [参考答案]("https://github.com/azl397985856/fe-interview/blob/master/docs/daily/2019-07-30.md")
### 数组
#### 数组复制
+ duplicate

>完成duplicate函数，  使之功能复合duplicate�([1,2,3,4,5]); // [1,2,3,4,5,1,2,3,4,5]

```js
function duplicate(list) {
  const len = list.length;
  for (let i = len; i < len * 2; i++) {
    list[i] = list[i - len];
  }
  return list;
}
```
ps:个人想法concat

>完成 duplicate 函数， 使之功能复合 duplicate�([1,2,3,4,5]); // [1,1,2,2,3,3,4,4,5,5]
```js
function duplicate(list) {
  let slow = list.length - 1;
  let fast = list.length * 2 - 1;
  let cnt = 0;

  while (slow < fast) {
    list[fast] = list[slow];
    if (cnt % 2 === 1) {
      slow--;
    }
    fast--;
    cnt++;
  }
  return list;
}
```


#### 数组去重
+   set方法（ES6）
```js
var array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];
Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]
```

+ Implementation（ES5）
 
```js
var array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];
uniqueArray(array); // [1, 2, 3, 5, 9, 8]
function uniqueArray(array) {
  var hashmap = {};
  var unique = [];
  for(var i = 0; i < array.length; i++) {
    // If key returns null (unique), it is evaluated as false.
    if(!hashmap.hasOwnProperty([array[i]])) {
      hashmap[array[i]] = 1;
      unique.push(array[i]);
    }
  }
  return unique;
}
```
#### 数组交集
给定两个数组，要求求出两个数组的交集，注意，交集中的元素应该是唯一的。
```js
var firstArray = [2, 2, 4, 1];
var secondArray = [1, 2, 0, 2];

intersection(firstArray, secondArray); // [2, 1]

function intersection(firstArray, secondArray) {
  // The logic here is to create a hashmap with the elements of the firstArray as the keys.
  // After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash
  // If it does exist, add that element to the new array.

  var hashmap = {};
  var intersectionArray = [];

  firstArray.forEach(function(element) {
    hashmap[element] = 1;
  });

  // Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added
  secondArray.forEach(function(element) {
    if (hashmap[element] === 1) {
      intersectionArray.push(element);
      hashmap[element]++;
    }
  });

  return intersectionArray;

  // Time complexity O(n), Space complexity O(n)
}
```
### 对象
+ 数据格式转化1
```js
//已知数据格式

var entry = {
  a: {
    b: {
      c: {
        dd: "abcdd"
      }
    },
    d: {
      xx: "adxx"
    },
    e: "ae"
  }
};

//要求转换成如下对象

var output = {
  "a.b.c.dd": "abcdd",
  "a.d.xx": "adxx",
  "a.e": "ae"
}
```

  - 思路

  这道题是典型的DFS。这里有个技巧，就是将res作为参数传过去， 从而子函数（helper）可以对其进行修改。 这样我们可以不必依赖返回值， 也就避免了很多判断。

```js
function helper(entry, prefix, res) {
  for (const key in entry) {
    if (entry[key] instanceof Object) {
      helper(entry[key], `${prefix}.${key}`, res);
    } else {
      res[`${prefix.slice(1)}.${key}`] = entry[key];
    }
  }
}

function format(entry) {
  const res = {};
  helper(entry, "", res);
  return res;
}
```


### cookie
### ES6
#### promise
+ 以下四个promise有什么不同
```js
doSomething().then(function () {
  return doSomethingElse();
});

doSomething().then(function () {
  doSomethingElse();
});

doSomething().then(doSomethingElse());

doSomething().then(doSomethingElse);
```

+ 答案
  1. then方法提供一个自定义的回调函数，若传入非函数，则会忽略当前then方法。
  2. 在回调函数中会把上一个then中返回的值当做参数值供当前then方法调用。
  3. then方法执行完毕后需要返回一个新的值给下一个then调用（没有返回值默认使用undefined）。
  4. 每个then只可能使用前一个then的返回值


## node
## vue
## 小程序
## 其他
### 性能优化
+ 页面注入50万个li怎么做提升性能

  因此一个简单且直观的想法是，在必要的时候我们再去DOM中插入。 我们可以利用“视口检测”技术判断当前是否应该去插入li。但是这里有个问题， 就是如果用户滚动太快怎么办？ 不在视口的DOM需不需要回收？ 如果需要回收，我们应该怎么回收？ 这些都需要大家去思考。大家可以查一下相关的资料。

  由于插入50个li，如果一个一个插入肯定会不断重排，性能会很差。 我们可以考虑使用createDocumentFragment 来减少重排的次数。

  我们创建50个li的过程是否会涉及到后端请求，如果涉及到了，我们一次请求多少比较合适？ 我们需不需要进行预先请求。 如果本地网络IO很差的话，如何尽可能提高用户体验？

  其实性能是一个相当主观的东西， 比如React使用了fiber架构，它的总运行时间 甚至比以前还要长，但是给用户的感觉是“性能好”。因此性能优化其实还有很多 讨巧的点可以考虑，大家不妨发散一下脑洞。

### 加密
+ 实现一个对称加密算法
  我们在互联网中的操作如果没有经过加密算法的加密是非常危险的，使用HTTPS是一个很好的选择， 它基于TSL/SSL 对传输层的内容进行加密。 尽管其中的核心算法是非对称加密， 但是真正传输数据的过程仍然是对称加密，其原因就是非对称加密的复杂性。

  那么如何实现一个对称加密算法呢？补充代码，使之符合预期。
  ```js
    function encrpt(msg, key) {
    // 补充代码
  }

  function decrypt(secretMsg, key) {
    // 补充代码
  }

  const msg = "hello";
  const key = null; // key can be anything

  const secretMsg = encrpt(msg, key);


  console.log(secretMsg);  // secretMsg !== msg

  console.log(decrypt(secretMsg, key) === msg);  // true
  ```
  参考代码
  ```js
  function encrpt(msg, key) {
  // 补充代码
  const secretMsg = [];
  for (let i = 0; i < msg.length; i++) {
    secretMsg[i] = msg[i].charCodeAt() + key;
  }

  return secretMsg.join('\n');
  }

  function decrypt(msg, key) {
  // 补充代码
  const secretMsg = msg.split('\n')
  const ret = [];
  for (let i = 0; i < secretMsg.length; i++) {
    ret[i] = String.fromCharCode(secretMsg[i] - key);
  }

  return ret.join("");
  }

  const msg = "hello";
  const key = 3;

  const secretMsg = encrpt(msg, key);

  decrypt(secretMsg, key) === msg;

  console.log(secretMsg);  // secretMsg !== msg

  console.log(decrypt(secretMsg, key) === msg);  // true
  ```
