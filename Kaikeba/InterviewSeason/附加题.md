## 2月22日作业解析

**1、js中基础数据类型有哪几种?了解包装对象么？**


**2、如何判断this？箭头函数的this是什么？**

## 2月23日作业解析

**1.什么是回调?回调使用中存在什么问题?**

回调函数是指一个函数作为参数传递给另一个函数并在这个函数执行;

回调任务过多少时会产生阻塞,逻辑混乱等问题


**2.Promise.allSettled 了解吗？动手实现一下 Promise.allSettled?**

Promise.all参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）
如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。

Promise.allSettled()方法返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果。
如果我们请求多个接口需要统计错误的次数，就可以用到此方法.

实现

## 2月24日作业解析
1.说下vue生命周期钩子函数?
2.vue中computed和watch区别?

1. BeforeCreate函数：
在实例初始化后被调用 ，这个时候的this 不能用，在data中的数据 methods的方法 还有 watcher中的事件 都获取不到
2.Created函数：
实例已经创建完成了，实例对象已经完成了，这时候可以访问 data 中的 数据 ，一级 methods中的方法和 watcher 中的事件了，但是 不能操作 dom 节点
挂载阶段。
3.Beforemounte：
在挂载开始前被调用 render函数 第一次被调用
4.mounted:
挂载完毕 ，这时候可以使用 dom 节点 ，一些需要dom的操作这时候才可以进行
5.BeforeUpdate
组件更新前 也就是说 数据 更新了 但是vue中的组件（事件）对应dom 内部中的数据没有变 所以说叫做组件更新前
6.Updated
组件更新完成之后的操作
ue中的组件（事件）已经对应dom 内部中的数据了
7.beforeDestroy
实例销毁之前调用 ，在 这个时候实例还是可以用的
8.Destroy
摧毁阶段 vue的 生命周期结束 ，实例 不能用了

①从属性名上，computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数。
②从实现上，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算。watch在每次监听的值变化时，都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。
③watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。computed通常就是简单的计算。
④watch和computed并没有哪个更底层，watch内部调用的是vm.$watch，它们的共同之处就是每个定义的属性都单独建立了一个Watcher对象。




## 2月25日作业解析

1. 说一下React Hooks在平时开发中需要注意的问题和原因?

使用hook时，react不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行其内部的所有逻辑，那么会带来较大的性能损耗。这里我们使用useCallback和useMemo可以优化性能问题。
（1）useCallback和useMemo的参数跟useEffect一致。
（2）useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。



2. React 的 setState 方法是异步还是同步？

setState它本身的方法调用是同步的，但是并不代表着调用了setState后，state立刻就更新了，这个更新是要根据我们当前执行环境的上下文来确定的。

如果处于批量更新的情况下，那我的state就不是立马更新了;
如果不处于这个批量更新的情况下，那就有可能是立马更新了，但也不一定，比如说，这里我处于一个异步渲染的情况下，
为了让避免这种情况，可以使用setState中传入一个回调函数作为第二个参数来解决

this.setState({
      value:100
},()=>{
   //这个回调函数会在更新状态时执行，所以可以获取到最新的值
})



## 2月26日作业解析

1、介绍一下 node 常用模块，并且详细介绍下 Stream?

 答案：
Buffer - 缓冲器
fs - 文件系统
http - HTTP/https - HTTPS
path - 路径
stream - 流
url - URL
zlib - 压缩

Node.js中有四种基本的流类型，如下：

1. Readable--可读的流(比如 fs.createReadStream()).
2. Writable--可写的流(比如 fs.createWriteStream()).
3. Duplex--可读写的流
4. Transform---在读写过程中可以修改和变换数据的Duplex流。

nodeJS中的流最大的作用是：读取大文件的过程中，不会一次性的读入到内存中。每次只会读取数据源的一个数据块。
然后后续过程中可以立即处理该数据块(数据处理完成后会进入垃圾回收机制)。而不用等待所有的数据。


2、Node 如何和 MySQL 进行通信?

 答案：
安装下载一个支持mysql的插件
cnpm install mysql –save-dev
2.写dbserver.js连接数据库

const mysql=require('mysql');

const DB_CONFIG={
    host:'主机名',
    port:0,//端口号
    user:'用户名',
    password:'密码',
    database:'数据库实例'
}

const dbserver=function(sql,arr,fn){
    let conn=mysql.createConnection(DB_CONFIG);
    conn.connect();
    conn.query(sql,arr,(err,result)=>{
        if(err) throw err;
        fn(result)
    });
    conn.end();
}





## 2月27日作业解析
## 2月28日作业解析
## 3月1日作业解析
一、客户端缓存有几种方式?浏览器出现 from disk、from memory 的 策略是啥?
from memory cache：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况

from disk cache：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache

资源本身大小数值：当http状态为200是实实在在从浏览器获取的资源，当http状态为304时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的


二、说一下 CORS 的简单请求和复杂请求的区别?

简单请求的发送从代码上来看和普通的XHR没太大区别，但是HTTP头当中要求总是包含一个域（Origin）的信息。该域包含协议名、地址以及一个可选的端口。

复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种"预请求"，此时作为服务端，也需要返回"预回应"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。

## 3月2日作业解析

1、简述http常见状态码有哪些？

a. 2开头状态码；2xx (成功)表示成功处理了请求的状态代码；如：200 (成功) 服务器已成功处理了请求。
b. 3开头状态码；3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。如：304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容
c. 4开头状态码；4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理；如：400 (错误请求) 服务器不理解请求的语法；403 (禁止) 服务器拒绝请求。404 (未找到) 服务器找不到请求的网页。
d. 5开头状态码；5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错；如：500 (服务器内部错误) 服务器遇到错误，无法完成请求


2、什么是 XSS 攻击？如何防范 XSS 攻击？

攻击者往 web 页面里插入恶意的 HTML 代码（Javascript、css、html 标签等），当用户浏览该页面时，嵌入其中的 HTML 代码会被执行，从而达到恶意攻击用户的目的。如盗取用户 cookie 执行一系列操作，破坏页面结构、重定向到其他网站等。
防范 :
web 页面中可由用户输入的地方，如果对输入的数据转义、过滤处理
后台输出页面的时候，也需要对输出内容进行转义、过滤处理（因为攻击者可能通过其他方式把恶意脚本写入数据库）
前端对 html 标签属性、css 属性赋值的地方进行校验

## 3月3日作业解析
1、mixin 和 mixins 区别？

mixin用于全局注册一个混入，如果有公共的组件使用频率很高的话，可以使用mixin很方便的引入公共的部分mixins选项接受一个混入对象的数组，mixins在引入组件之后，则是将组件内部的内容如data属性，methods方法与父组件的内容相对应进行合并，可以对父组件的属性进行扩充，mixins混入的钩子函数会优先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。


2、vue2中为什么检测不到数组的 变化，如何解决?

其实vue是可以针对数组的变动进行检测而触发响应式更新视图,
真正限制vue无法对数组进行动态响应的根本原因，来源于JavaScript对数组操作的限制。对于对象而言，每一次的数据变更都会对对象的属性进行一次枚举，一般对象本身的属性数量有限，所以对于遍历枚举等方式产生的性能损耗可以忽略不计，但是对于数组而言呢？数组包含的元素量是可能达到成千上万，假设对于每一次数组元素的更新都触发了枚举/遍历，其带来的性能损耗将与获得的用户体验不成正比，故vue无法检测数组的变动。

在vue3.0中，使用proxy代理模式替代Object.defineProperty()，其在代码层面将更加简洁，执行效率也大幅提升，数据检测也由属性转变为对象，即可解决数组监听问题

## 3月4日作业解析

1、是否使用过 React Portals，在什么场景下？ 

插槽(Portals)能将子节点渲染到父组件的 DOM 层次之外

2、在函数组件中，如何获取组件更新前的 state?

在函数组件中使用 State 特性需要通过hook

## 3月5日作业解析


问题1：按要求实现 go 函数？
// 示例
go("l"); //gol
go()("l"); //gool
go()()("l"); //返回goool


function go(l) {
    let original = 'go';
    let fn = function(l) {
        if(l) {
            original += l;
            return original;
        }
        original += 'o';
        return fn;
    }
    return fn(l);
}


问题2：实现一个myMap函数,实现类似map功能？

    Array.prototype.myMap = function (fn, context) {
        var arr = []
        if (typeof fn !== 'function') {
            throw new Error('参数错误')
        }

        var len = this.length
        for (var k = 0; k < len; k++) {
            arr.push(fn.call(context, this[k], k, this))
        }

        return arr;
    }



## 3月6日作业解析
## 3月7日作业解析
## 3月8日作业解析
## 3月9日作业解析
## 3月10日作业解析
## 3月11日作业解析
## 3月12日作业解析
## 3月13日作业解析
## 3月14日作业解析
## 3月15日作业解析
## 3月16日作业解析
## 3月17日作业解析
## 3月18日作业解析

