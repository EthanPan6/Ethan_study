## 2月22日作业解析
**1. 编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。**

特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。
如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1？   

答案： 

这道题目考察数组的常用基本操作方法。思路是先做数组内部值的排序，排序完成之后因为需要由大到小所以在反转下数组 。最后在做数组的去重处理，最终返还答案。实现代码如下：    

```js
function getNum(k, arr) {        
    // 排列数组及反转        
    let res = arr.sort((a,b)=>b-a);        
    // 将数组转化成set去重        
    let set = new Set(res);        
    // 将类数组转回数组        
    let newArr = Array.from(set);        
    if (typeof newArr[k-1] !== "undefined") {            
        // 返回查找到的数据            
        return newArr[k-1];        
        } else {            
            // 未找到数据排除错误            
            throw Error("未找到对应数据");        
        }    
}    
let arr = [3, 1, 3, 2, 5, 4, 5];    
let res = getNum(1, arr);    
console.log(res);
```

**2. `__proto__` 和 `prototype` 之前有什么关系? **

答案： 
所有对象都有 `__proto__ `属性，函数这个特殊对象除了具有 `__proto__` 属性，还有特有的原型属性prototype。
prototype对象默认有两个属性，constructor属性和`__proto__` 属性。
prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而`__proto__` 是查找某函数或对象的原型链方式。
constructor，这个属性包含了一个指针，指回原构造函数。  

**3. call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？**

答案 ：
call 、apply 、bind 作用是 改变函数执行时的上下文，简而言之就是改变函数运行时的this指向。区别在于调用方式及参数传递上。
具体如下：    
```js
function fn(...args){        
    console.log(this,args);    
}    
fn(1,2);  
// fn函数默认this指向是 window对象    
let obj = {        
    myname:"张三"    
}    
fn.call(obj,1,2);  
// this 会变成 传入的obj ，args 会变成[1,2];    
fn.apply(obj,[1,2]); 
// this会变成传入的obj ，传入的参数必须是一个数组；    
fn.bind(obj)(1,2); 
// this 也会变成传入的obj ，bind不是立即执行需要执行一次
```
综上所述call、apply、bind都可以改变this指向，区别在于 参数传递方式不同，call、apply是立即执行bind不是立即执行。
bind实现如下：
```js
Function.prototype.myBind = function (context) {   
    // 判断调用对象是否为函数   
    if (typeof this !== "function") {     
        throw new TypeError("Error");   
    }   
    // 获取参数   
    var args = [...arguments].slice(1),     
    fn = this;   
    return function Fn() {     
        // 根据调用方式，传入不同绑定值     
        return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments));   
    } 
}
```

## 2月23日作业解析
**1、 如何中断ajax请求？  **

答案 ： 
原生里可以通过XMLHttpRequest对象上的abort方法来中断ajax。注意abort方法不能阻止向服务器发送请求，只能停止当前ajax请求。

**2、 什么是同步？什么是异步？ **

答案： 
同步和异步是一种消息通知机制– 同步阻塞: A调用B，B处理获得结果，才返回给A。A在这个过程中，一直等待B的处理结果，没有拿到结果之前，需要A（调用者）一直等待和确认调用结果是否返回，拿到结果,然后继续往下执行。   做一件事，没有拿到结果之前，就一直在这等着，一直等到有结果了,再去做下边的事– 异步非阻塞: A调用B，无需等待B的结果，B通过状态，通知等来通知A或回调函数来处理。 

**3、 什么是宏任务？什么是微任务？ ** 

答案：
+ 微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。  
+ 宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。 

常见微任务：  
* Promise.then
* MutaionObserver
* Object.observe（已废弃；Proxy 对象替代）
* process.nextTick（Node.js）  

常见宏任务 ：    
1. script (可以理解为外层同步代码)  
2. setTimeout/setInterval  
3. UI rendering/UI事件  
4. postMessage，MessageChannel  
5. setImmediate，I/O（Node.js）