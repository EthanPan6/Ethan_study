## 2月22日作业解析
**1. 编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。**

特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。
如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1？   

答案： 

这道题目考察数组的常用基本操作方法。思路是先做数组内部值的排序，排序完成之后因为需要由大到小所以在反转下数组 。最后在做数组的去重处理，最终返还答案。实现代码如下：    

```js
function getNum(k, arr) {        
    // 排列数组及反转        
    let res = arr.sort((a,b)=>b-a);        
    // 将数组转化成set去重        
    let set = new Set(res);        
    // 将类数组转回数组        
    let newArr = Array.from(set);        
    if (typeof newArr[k-1] !== "undefined") {            
        // 返回查找到的数据            
        return newArr[k-1];        
        } else {            
            // 未找到数据排除错误            
            throw Error("未找到对应数据");        
        }    
}    
let arr = [3, 1, 3, 2, 5, 4, 5];    
let res = getNum(1, arr);    
console.log(res);
```

**2. `__proto__` 和 `prototype` 之前有什么关系? **

答案： 
所有对象都有 `__proto__ `属性，函数这个特殊对象除了具有 `__proto__` 属性，还有特有的原型属性prototype。
prototype对象默认有两个属性，constructor属性和`__proto__` 属性。
prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而`__proto__` 是查找某函数或对象的原型链方式。
constructor，这个属性包含了一个指针，指回原构造函数。  

**3. call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？**

答案 ：
call 、apply 、bind 作用是 改变函数执行时的上下文，简而言之就是改变函数运行时的this指向。区别在于调用方式及参数传递上。
具体如下：    
```js
function fn(...args){        
    console.log(this,args);    
}    
fn(1,2);  
// fn函数默认this指向是 window对象    
let obj = {        
    myname:"张三"    
}    
fn.call(obj,1,2);  
// this 会变成 传入的obj ，args 会变成[1,2];    
fn.apply(obj,[1,2]); 
// this会变成传入的obj ，传入的参数必须是一个数组；    
fn.bind(obj)(1,2); 
// this 也会变成传入的obj ，bind不是立即执行需要执行一次
```
综上所述call、apply、bind都可以改变this指向，区别在于 参数传递方式不同，call、apply是立即执行bind不是立即执行。
bind实现如下：
```js
Function.prototype.myBind = function (context) {   
    // 判断调用对象是否为函数   
    if (typeof this !== "function") {     
        throw new TypeError("Error");   
    }   
    // 获取参数   
    var args = [...arguments].slice(1),     
    fn = this;   
    return function Fn() {     
        // 根据调用方式，传入不同绑定值     
        return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments));   
    } 
}
```

## 2月23日作业解析
**1、 如何中断ajax请求？  **

答案 ： 
原生里可以通过XMLHttpRequest对象上的abort方法来中断ajax。注意abort方法不能阻止向服务器发送请求，只能停止当前ajax请求。

**2、 什么是同步？什么是异步？ **

答案： 
同步和异步是一种消息通知机制– 同步阻塞: A调用B，B处理获得结果，才返回给A。A在这个过程中，一直等待B的处理结果，没有拿到结果之前，需要A（调用者）一直等待和确认调用结果是否返回，拿到结果,然后继续往下执行。   做一件事，没有拿到结果之前，就一直在这等着，一直等到有结果了,再去做下边的事– 异步非阻塞: A调用B，无需等待B的结果，B通过状态，通知等来通知A或回调函数来处理。 

**3、 什么是宏任务？什么是微任务？ ** 

答案：
+ 微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。  
+ 宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。 

常见微任务：  
* Promise.then
* MutaionObserver
* Object.observe（已废弃；Proxy 对象替代）
* process.nextTick（Node.js）  

常见宏任务 ：    
1. script (可以理解为外层同步代码)  
2. setTimeout/setInterval  
3. UI rendering/UI事件  
4. postMessage，MessageChannel  
5. setImmediate，I/O（Node.js）

## 2月23日作业解析

**1.vue 中组件间有哪些通信方式?**

**props 和 $emit:**props和emit这是我们日常开发中最常使用的组件通信方式。父组件通过绑定属性来向子组件传递数据，子组件通过props属性来获取对应的数据，子组件则是通过派发emit这是我们日常开发中最常使用的组件通信方式。父组件通过绑定属性来向子组件传递数据，子组件通过 props 属性来获取对应的数据，子组件则是通过派发 emit这是我们日常开发中最常使用的组件通信方式。父组件通过绑定属性来向子组件传递数据，子组件通过props属性来获取对应的数据，子组件则是通过派发emit事件将数据传递到父组件中。

**children/parent:**⽗组件可以通过children访问⼦组件，子组件可以通过children访问⼦组件，子组件可以通过parent来访问父组件，不过一般情况下不推荐通过这种方式来实现组件通信。

**ref:** 访问子组件实例或子元素，使用后可以直接访问子组件的数据或调用子组件的方法。

**eventBus:**任意两个组件之间传值常⽤事件总线。

**Vuex:**Vuex是一个专为Vue.js应用程序开发的状态管理模式，通过它集中式的管理数据并通知组件状态变更。推荐在项目复杂的情况下使用。

**provide 和 inject:** 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。用于祖先组件和后代组件之间的通信，无论组件的层次有多深。

**attrs和listeners:**包含了⽗作⽤域中不作为 prop 被识别(且获取)的特性绑定(class和style除外)。当⼀个组件没有声明任何 prop 时，这⾥会包含所有⽗作⽤域的绑定(class 和 style 除外)，并且可以通过 v-bind=" $attrs"传⼊内部组件—在创建⾼级别的组件时⾮常有⽤。

**2.vue 中 v-show 和 v-if 的区别是什么？**

v-if直接不渲染,v-show会插入真实dom然后display:none不显示在页面中

**3.keep-alive 组件有什么作用？**

<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。
它提供了include与exclude两个属性，允许组件有条件地进行缓存。

## 2月23日作业解析

React 的组件间通信都有哪些形式？

父==>子:父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。
子==>父:父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信
兄弟:以父为中介
跨级组件间通信：使用 context 对象
非嵌套组件间通信：使用事件订阅
任意组件间:redux,flux等状态管理工具

React 中如何实现路由懒加载？

1. webpack的lazyload-loader插件
2. 使用React自带的 Suspense,lazy实现懒加载

React 的生命周期函数都有哪些，分别有什么作用？

挂载期
constructor 数据接收 实现继承super(props)
componentWillMount 数据挂载之前 可以操作数据 不可以操作dom
componentDidMount 数据挂载之后 可以操作数据和dom
render 渲染组件 和 html 标签

更新期
shouldComponentUpdate 检测组件内的变化 可以用作页面性能的优化(默认值为true)
componentReceiveProps 接收组件传入输入数据
componentWillUpdate 组件更新之前调用
componentDidUpdate 组件更新之后调用
render 组件更新之后渲染组件

销毁期
componentWillUnmount 组件销毁时调用 可以做一些内存的优化 (全局变量,闭包,计时器,事件)


## 2月24日作业解析


1.有没有写过 Koa 中间件，说下中 间件原理，介绍下自己写过的中间件?

没有

2.如何判断当前脚本运行在浏览器还是node环境中？

通过判断 Global 对象是否为 window ，如果不为window ，当前脚本没有运行在浏览器中

3.请描述一下 cookies sessionStorage和localstorage区别？

SessionStorage, LocalStorage, Cookie这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。 区别在于前两者属于WebStorage，创建它们的目的便于客户端存储数据

Cookie是服务器发送到用户浏览器并保存在浏览器上的一块数据， 它会在浏览器下一次发起请求时被携带并发送到服务器上。比较经典的，可以它用来确定两次请求是否来自于同一个浏 览器，从而能够确认和保持用户的登录状态。

localStorage 是 HTML5 标准中新加入的技术，通常用他来存储较大量数据。

sessionStorage 与 localStorage 的接口类似， 但保存数据的生命周期与 localStorage 不同。 它只 是可以将一部分数据在当前会话中保存下来， 刷新页面数据依旧存在。 但当页面关闭后，sessionStorage 中的数据就会被清空